<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Combo Kitchen üç≥üõπ ‚Äî Skateboarding Trick Combo Generator</title>
  <meta name="description" content="Generate random skateboarding trick combos for your practice sessions. Pick your skill level and cook up fresh lines.">
  <meta property="og:title" content="Combo Kitchen ‚Äî Skate Trick Combo Generator">
  <meta property="og:description" content="Cook up fresh skateboarding trick combos for your next session.">
  <meta property="og:type" content="website">
  <meta property="og:url" content="https://clawdiard.github.io/combo-kitchen/">
  <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>üç≥</text></svg>">
  <style>
    :root {
      --bg: #1a1a2e;
      --surface: #16213e;
      --primary: #e94560;
      --secondary: #0f3460;
      --text: #eee;
      --text-dim: #999;
      --accent: #f5c518;
    }
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
      background: var(--bg);
      color: var(--text);
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    header {
      text-align: center;
      padding: 2rem 1rem 1rem;
    }
    header h1 {
      font-size: 2.5rem;
      font-weight: 800;
      letter-spacing: -1px;
    }
    header h1 span { color: var(--primary); }
    header p {
      color: var(--text-dim);
      margin-top: 0.3rem;
      font-size: 1.05rem;
    }
    .controls {
      display: flex;
      gap: 0.75rem;
      flex-wrap: wrap;
      justify-content: center;
      margin: 1.5rem 0;
      padding: 0 1rem;
      box-sizing: border-box;
      max-width: 100%;
    }
    .btn {
      padding: 0.65rem 1.4rem;
      border: 2px solid var(--secondary);
      background: var(--surface);
      color: var(--text);
      border-radius: 999px;
      font-size: 0.95rem;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.15s;
    }
    .btn:hover { border-color: var(--primary); }
    .btn.active {
      background: var(--primary);
      border-color: var(--primary);
      color: #fff;
    }
    .generate-btn {
      background: var(--primary);
      border: none;
      color: #fff;
      padding: 1rem 2.5rem;
      border-radius: 999px;
      font-size: 1.2rem;
      font-weight: 700;
      cursor: pointer;
      transition: transform 0.1s, box-shadow 0.15s;
      box-shadow: 0 4px 20px rgba(233, 69, 96, 0.3);
      margin: 0.5rem 0 1.5rem;
    }
    .generate-btn:hover {
      transform: scale(1.05);
      box-shadow: 0 6px 30px rgba(233, 69, 96, 0.5);
    }
    .generate-btn:active { transform: scale(0.98); }
    .combo-display {
      width: 90%;
      max-width: 700px;
      min-height: 200px;
      background: var(--surface);
      border-radius: 16px;
      padding: 2rem;
      text-align: center;
      position: relative;
      margin-bottom: 1rem;
    }
    .combo-display.empty {
      display: flex;
      align-items: center;
      justify-content: center;
      color: var(--text-dim);
      font-size: 1.1rem;
    }
    .combo-tricks {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
      align-items: center;
    }
    .trick-card {
      background: var(--secondary);
      border-radius: 12px;
      padding: 1rem 1.5rem;
      width: 100%;
      max-width: 500px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      animation: slideIn 0.3s ease-out;
    }
    .trick-card:nth-child(even) { animation-delay: 0.05s; }
    @keyframes slideIn {
      from { opacity: 0; transform: translateY(10px); }
      to { opacity: 1; transform: translateY(0); }
    }
    .trick-name {
      font-size: 1.15rem;
      font-weight: 700;
    }
    .trick-meta {
      display: flex;
      gap: 0.5rem;
      align-items: center;
    }
    .trick-stance {
      font-size: 0.75rem;
      background: rgba(255,255,255,0.1);
      padding: 0.2rem 0.5rem;
      border-radius: 6px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    .trick-difficulty {
      display: flex;
      gap: 2px;
    }
    .dot {
      width: 8px; height: 8px;
      border-radius: 50%;
      background: var(--text-dim);
    }
    .dot.filled { background: var(--accent); }
    .connector {
      color: var(--primary);
      font-weight: 600;
      font-size: 0.9rem;
      text-transform: uppercase;
      letter-spacing: 1px;
    }
    .combo-stats {
      margin-top: 1.5rem;
      padding-top: 1rem;
      border-top: 1px solid rgba(255,255,255,0.1);
      display: flex;
      justify-content: center;
      gap: 2rem;
      font-size: 0.9rem;
      color: var(--text-dim);
    }
    .combo-stats strong { color: var(--accent); }
    .history {
      width: 90%;
      max-width: 700px;
      margin: 1rem 0 3rem;
    }
    .history h3 {
      font-size: 0.9rem;
      color: var(--text-dim);
      text-transform: uppercase;
      letter-spacing: 1px;
      margin-bottom: 0.75rem;
    }
    .history-item {
      background: var(--surface);
      border-radius: 10px;
      padding: 0.75rem 1rem;
      margin-bottom: 0.5rem;
      font-size: 0.9rem;
      cursor: pointer;
      transition: background 0.15s;
    }
    .history-item:hover { background: var(--secondary); }
    .options-row {
      display: flex;
      gap: 0.75rem;
      flex-wrap: wrap;
      justify-content: center;
      margin-bottom: 0.5rem;
    }
    .option-group label {
      font-size: 0.8rem;
      color: var(--text-dim);
      text-transform: uppercase;
      letter-spacing: 0.5px;
      display: block;
      margin-bottom: 0.3rem;
      text-align: center;
    }
    .fav-btn {
      background: none;
      border: 2px solid var(--primary);
      color: var(--primary);
      padding: 0.5rem 1rem;
      border-radius: 8px;
      cursor: pointer;
      font-size: 1rem;
      margin-top: 0.5rem;
      transition: all 0.2s;
    }
    .fav-btn:hover { background: var(--primary); color: #fff; }
    .fav-btn.saved { background: var(--primary); color: #fff; }
    .share-btn {
      display: inline-flex; align-items: center; gap: 0.4rem;
      margin-top: 0.75rem; margin-left: 0.5rem;
      padding: 0.5rem 1.2rem; background: var(--secondary); color: var(--text);
      border: 2px solid var(--text-dim); border-radius: 999px;
      font-size: 0.9rem; font-weight: 600; cursor: pointer; transition: all 0.15s;
    }
    .share-btn:hover { border-color: var(--primary); background: var(--primary); color: #fff; }
    .share-btn.copied { border-color: #4caf50; background: #4caf50; color: #fff; }
    .combo-actions { display: flex; justify-content: center; gap: 0.5rem; flex-wrap: wrap; }
    .share-toast {
      position: fixed; bottom: 2rem; left: 50%; transform: translateX(-50%) translateY(100px);
      background: #4caf50; color: #fff; padding: 0.75rem 1.5rem; border-radius: 999px;
      font-weight: 700; font-size: 0.95rem; z-index: 999; opacity: 0;
      transition: all 0.3s ease; pointer-events: none;
    }
    .share-toast.show { transform: translateX(-50%) translateY(0); opacity: 1; }
    .favorites { width: 90%; max-width: 600px; margin: 1.5rem auto; }
    .favorites h3 { color: var(--accent); margin-bottom: 0.75rem; }
    .fav-item {
      background: var(--surface);
      padding: 0.75rem 1rem;
      border-radius: 8px;
      margin-bottom: 0.5rem;
      display: flex;
      justify-content: space-between;
      align-items: center;
      cursor: pointer;
    }
    .fav-item:hover { outline: 1px solid var(--primary); }
    .fav-item .fav-text { flex: 1; }
    .fav-item .fav-meta { color: var(--text-dim); font-size: 0.8rem; margin-top: 0.2rem; }
    .fav-remove {
      background: none;
      border: none;
      color: var(--text-dim);
      cursor: pointer;
      font-size: 1.2rem;
      padding: 0.25rem 0.5rem;
    }
    .fav-remove:hover { color: var(--primary); }
    footer {
      text-align: center;
      padding: 2rem;
      color: var(--text-dim);
      font-size: 0.85rem;
    }
    footer a { color: var(--primary); text-decoration: none; }
    /* Timer Mode */
    .timer-toggle {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      justify-content: center;
      margin-bottom: 1rem;
    }
    .timer-toggle label {
      font-size: 0.9rem;
      color: var(--text-dim);
      cursor: pointer;
    }
    .toggle-switch {
      position: relative;
      width: 48px;
      height: 26px;
      cursor: pointer;
    }
    .toggle-switch input { display: none; }
    .toggle-slider {
      position: absolute;
      inset: 0;
      background: var(--secondary);
      border-radius: 999px;
      transition: background 0.2s;
    }
    .toggle-slider::after {
      content: '';
      position: absolute;
      width: 20px; height: 20px;
      left: 3px; top: 3px;
      background: var(--text-dim);
      border-radius: 50%;
      transition: transform 0.2s, background 0.2s;
    }
    .toggle-switch input:checked + .toggle-slider {
      background: var(--primary);
    }
    .toggle-switch input:checked + .toggle-slider::after {
      transform: translateX(22px);
      background: #fff;
    }
    .timer-bar-container {
      width: 90%;
      max-width: 700px;
      height: 8px;
      background: var(--secondary);
      border-radius: 999px;
      overflow: hidden;
      margin: 0 auto 1rem;
      display: none;
    }
    .timer-bar-container.active { display: block; }
    .timer-bar {
      height: 100%;
      background: var(--accent);
      border-radius: 999px;
      transition: width 0.1s linear, background 0.3s;
      width: 100%;
    }
    .timer-bar.warning { background: #ff9800; }
    .timer-bar.danger { background: var(--primary); }
    .timer-display {
      text-align: center;
      font-size: 2rem;
      font-weight: 800;
      font-variant-numeric: tabular-nums;
      margin-bottom: 0.5rem;
      display: none;
    }
    .timer-display.active { display: block; }
    .timer-display.warning { color: #ff9800; }
    .timer-display.danger { color: var(--primary); animation: pulse 0.5s infinite alternate; }
    @keyframes pulse { from { opacity: 1; } to { opacity: 0.5; } }
    .timer-result {
      text-align: center;
      font-size: 1.3rem;
      font-weight: 700;
      margin-bottom: 1rem;
    }
    .timer-result.success { color: #4caf50; }
    .timer-result.fail { color: var(--primary); }
    .timer-actions {
      display: flex;
      gap: 0.75rem;
      justify-content: center;
      margin-bottom: 1rem;
      display: none;
    }
    .timer-actions.active { display: flex; }
    .timer-btn {
      padding: 0.6rem 1.5rem;
      border: none;
      border-radius: 999px;
      font-size: 1rem;
      font-weight: 700;
      cursor: pointer;
      transition: transform 0.1s;
    }
    .timer-btn:hover { transform: scale(1.05); }
    .timer-btn.landed { background: #4caf50; color: #fff; }
    .timer-btn.bail { background: var(--secondary); color: var(--text); border: 2px solid var(--text-dim); }
    .timer-settings {
      display: none;
      justify-content: center;
      gap: 0.5rem;
      margin-bottom: 0.75rem;
      align-items: center;
    }
    .timer-settings.active { display: flex; }
    .timer-settings label { font-size: 0.8rem; color: var(--text-dim); text-transform: uppercase; letter-spacing: 0.5px; }
    .timer-settings select {
      background: var(--surface);
      color: var(--text);
      border: 2px solid var(--secondary);
      border-radius: 8px;
      padding: 0.3rem 0.5rem;
      font-size: 0.9rem;
    }
    .timer-streak {
      text-align: center;
      font-size: 0.85rem;
      color: var(--text-dim);
      margin-bottom: 0.5rem;
      display: none;
    }
    .timer-streak.active { display: block; }
    .timer-streak strong { color: var(--accent); }
    /* Mode Tabs */
    .mode-tabs {
      display: flex;
      gap: 0;
      margin-bottom: 1rem;
      border-radius: 12px;
      overflow: hidden;
      border: 2px solid var(--secondary);
    }
    .mode-tab {
      flex: 1;
      padding: 0.6rem 1.2rem;
      background: transparent;
      color: var(--text-dim);
      border: none;
      font-size: 0.95rem;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
    }
    .mode-tab.active {
      background: var(--secondary);
      color: var(--text);
    }
    .mode-tab:hover:not(.active) { background: rgba(255,255,255,0.05); }

    /* Builder Panel */
    .builder-panel {
      display: none;
      width: 90%;
      max-width: 700px;
      margin: 1rem 0;
    }
    .builder-panel.active { display: block; }
    .trick-search-input {
      width: 100%;
      padding: 0.7rem 1rem;
      border-radius: 10px;
      border: 2px solid var(--secondary);
      background: var(--surface);
      color: var(--text);
      font-size: 1rem;
      margin-bottom: 0.75rem;
      outline: none;
    }
    .trick-search-input:focus { border-color: var(--primary); }
    .builder-trick-list {
      display: flex;
      flex-wrap: wrap;
      gap: 0.4rem;
      max-height: 200px;
      overflow-y: auto;
      padding: 0.5rem;
      background: var(--surface);
      border-radius: 12px;
      margin-bottom: 1rem;
    }
    .builder-trick-chip {
      padding: 0.35rem 0.7rem;
      border-radius: 8px;
      background: rgba(255,255,255,0.08);
      color: var(--text);
      font-size: 0.85rem;
      cursor: pointer;
      transition: all 0.15s;
      border: 1px solid transparent;
      white-space: nowrap;
    }
    .builder-trick-chip:hover {
      background: var(--primary);
      color: #fff;
    }
    .builder-trick-chip .chip-diff {
      color: var(--text-dim);
      font-size: 0.7rem;
      margin-left: 0.3rem;
    }
    .builder-workspace {
      background: var(--surface);
      border-radius: 14px;
      padding: 1rem;
    }
    .builder-combo { min-height: 60px; }
    .builder-empty { color: var(--text-dim); text-align: center; padding: 1rem; font-size: 0.9rem; }
    .builder-combo-item {
      display: flex;
      align-items: center;
      justify-content: space-between;
      background: rgba(255,255,255,0.05);
      border-radius: 10px;
      padding: 0.5rem 0.75rem;
      margin-bottom: 0.3rem;
    }
    .builder-combo-item .trick-label { font-weight: 600; }
    .builder-combo-item .remove-trick {
      background: none;
      border: none;
      color: var(--text-dim);
      cursor: pointer;
      font-size: 1.1rem;
      padding: 0 0.3rem;
    }
    .builder-combo-item .remove-trick:hover { color: var(--primary); }
    .builder-connector-select {
      display: flex;
      justify-content: center;
      padding: 0.2rem 0;
    }
    .builder-connector-select select {
      background: var(--bg);
      color: var(--accent);
      border: 1px solid var(--secondary);
      border-radius: 6px;
      padding: 0.2rem 0.5rem;
      font-size: 0.8rem;
      cursor: pointer;
    }
    .builder-actions {
      display: flex;
      gap: 0.75rem;
      justify-content: center;
      align-items: center;
      margin-top: 1rem;
      padding-top: 0.75rem;
      border-top: 1px solid rgba(255,255,255,0.1);
    }
  </style>
</head>
<body>
  <header>
    <h1>üç≥ Combo <span>Kitchen</span></h1>
    <p>Cook up fresh trick combos for your next session</p>
  </header>

  <div class="controls" id="levelBtns">
    <button class="btn" data-level="beginner">üü¢ Beginner</button>
    <button class="btn active" data-level="intermediate">üü° Intermediate</button>
    <button class="btn" data-level="advanced">üü† Advanced</button>
    <button class="btn" data-level="pro">üî¥ Pro</button>
  </div>

  <div class="options-row">
    <div class="option-group">
      <label>Stance Filter</label>
      <div class="controls" id="stanceBtns">
        <button class="btn active btn-sm" data-stance="all">All</button>
        <button class="btn btn-sm" data-stance="regular">Regular</button>
        <button class="btn btn-sm" data-stance="nollie">Nollie</button>
        <button class="btn btn-sm" data-stance="fakie">Fakie</button>
        <button class="btn btn-sm" data-stance="switch">Switch</button>
      </div>
    </div>
    <div class="option-group">
      <label>Category Filter</label>
      <div class="controls" id="categoryBtns">
        <button class="btn active btn-sm" data-category="all">All</button>
        <button class="btn btn-sm" data-category="flip">üîÑ Flips</button>
        <button class="btn btn-sm" data-category="shove">üîÉ Shove-Its</button>
        <button class="btn btn-sm" data-category="rotation">üåÄ Rotations</button>
        <button class="btn btn-sm" data-category="basics">üìó Basics</button>
        <button class="btn btn-sm" data-category="balance">‚öñÔ∏è Balance</button>
        <button class="btn btn-sm" data-category="old_school">üé© Old School</button>
      </div>
    </div>
  </div>

  <div class="timer-toggle">
    <label for="timerToggle">‚è±Ô∏è Timer Mode</label>
    <div class="toggle-switch">
      <input type="checkbox" id="timerToggle">
      <div class="toggle-slider"></div>
    </div>
  </div>

  <div class="timer-settings" id="timerSettings">
    <label>Time Limit</label>
    <select id="timerDuration">
      <option value="auto">Auto (by difficulty)</option>
      <option value="15">15s</option>
      <option value="30">30s</option>
      <option value="45">45s</option>
      <option value="60">60s</option>
      <option value="90">90s</option>
      <option value="120">2min</option>
    </select>
  </div>

  <div class="timer-streak" id="timerStreak">üî• Streak: <strong id="streakCount">0</strong></div>

  <div class="mode-tabs">
    <button class="mode-tab active" data-mode="random">üé≤ Random</button>
    <button class="mode-tab" data-mode="builder">üõ†Ô∏è Build Your Own</button>
  </div>

  <button class="generate-btn" id="generateBtn">üî• Cook a Combo</button>

  <!-- Builder Mode UI -->
  <div class="builder-panel" id="builderPanel">
    <div class="builder-search">
      <input type="text" id="trickSearch" placeholder="Search tricks..." class="trick-search-input">
    </div>
    <div class="builder-trick-list" id="builderTrickList"></div>
    <div class="builder-workspace">
      <h3 style="color:var(--text-dim);text-transform:uppercase;letter-spacing:1px;font-size:0.8rem;margin-bottom:0.75rem">Your Combo</h3>
      <div class="builder-combo" id="builderCombo">
        <div class="builder-empty">Pick tricks from above to build your combo</div>
      </div>
      <div class="builder-actions" id="builderActions" style="display:none">
        <button class="btn btn-sm" id="builderClear">üóëÔ∏è Clear</button>
        <button class="generate-btn" id="builderCook" style="font-size:1rem;padding:0.6rem 1.5rem">üç≥ Cook It!</button>
      </div>
    </div>
  </div>

  <div class="timer-display" id="timerDisplay">0:00</div>
  <div class="timer-bar-container" id="timerBarContainer"><div class="timer-bar" id="timerBar"></div></div>
  <div id="timerResult"></div>
  <div class="timer-actions" id="timerActions">
    <button class="timer-btn landed" id="landedBtn">‚úÖ Landed!</button>
    <button class="timer-btn bail" id="bailBtn">üíÄ Bailed</button>
  </div>

  <div class="combo-display empty" id="comboDisplay">
    <span>Hit the button to generate your first combo!</span>
  </div>

  <div class="history" id="historySection" style="display:none">
    <h3>üïê Recent Combos</h3>
    <div id="historyList"></div>
  </div>

  <div class="favorites" id="favoritesSection" style="display:none">
    <h3>‚≠ê Favorite Combos</h3>
    <div id="favoritesList"></div>
  </div>

  <div class="share-toast" id="shareToast"></div>

  <footer>
    <p>Built by <a href="https://github.com/clawdiard">Clawdia</a> ¬∑ <a href="https://github.com/clawdiard/combo-kitchen">Source</a></p>
  </footer>

  <script>
    let tricksData = null;
    let currentLevel = 'intermediate';
    let currentStance = 'all';
    let currentCategory = 'all';
    let history = [];

    async function loadTricks() {
      const res = await fetch('data/tricks.json');
      tricksData = await res.json();
      migrateFavorites();
    }

    // Schema version for favorites ‚Äî bump when tricks.json changes
    const FAVORITES_SCHEMA = 2;

    function migrateFavorites() {
      if (!tricksData || favorites.length === 0) return;
      const trickNames = new Set(tricksData.tricks.map(t => t.name));
      const trickMap = {};
      tricksData.tricks.forEach(t => { trickMap[t.name] = t; });

      // Build fuzzy name map for old ‚Üí new (e.g. "Nollie" ‚Üí "Nollie Ollie")
      const nameMap = {};
      tricksData.tricks.forEach(t => {
        // Map shortened versions to full name
        const words = t.name.split(' ');
        if (words.length > 1) {
          words.forEach(w => { if (!trickNames.has(w) && !nameMap[w]) nameMap[w] = t.name; });
        }
      });

      let changed = false;
      favorites.forEach(f => {
        if (!f.result || !f.result.combo) return;

        // Re-map trick names
        f.result.combo.forEach(trick => {
          if (!trickNames.has(trick.name) && nameMap[trick.name]) {
            const newName = nameMap[trick.name];
            const current = trickMap[newName];
            trick.name = newName;
            if (current) trick.difficulty = current.difficulty;
            changed = true;
          } else if (trickMap[trick.name] && trick.difficulty !== trickMap[trick.name].difficulty) {
            trick.difficulty = trickMap[trick.name].difficulty;
            changed = true;
          }
        });

        // Recompute totalDifficulty
        const newTotal = f.result.combo.reduce((s, t) => s + (t.difficulty || 0), 0);
        if (newTotal !== f.result.totalDifficulty) {
          f.result.totalDifficulty = newTotal;
          changed = true;
        }

        // Recompute level
        const newLevel = deriveLevelFromDifficulty(f.result.totalDifficulty, f.result.combo.length);
        if (newLevel !== f.level) {
          f.level = newLevel;
          changed = true;
        }

        // Update display text
        const newText = comboToString(f.result);
        if (newText !== f.text) {
          f.text = newText;
          f.key = f.result.combo.map(t => t.name).join('|');
          changed = true;
        }
      });

      if (changed) {
        saveFavorites();
        renderFavorites();
      }
    }

    function getFilteredTricks() {
      const level = tricksData.skill_levels[currentLevel];
      const minDiff = level.min_difficulty || 1;
      return tricksData.tricks.filter(t => {
        if (t.difficulty > level.max_difficulty) return false;
        if (t.difficulty < minDiff) return false;
        if (currentStance !== 'all' && !t.stance.includes(currentStance)) return false;
        if (currentCategory !== 'all' && t.category !== currentCategory) return false;
        return true;
      });
    }

    function pick(arr) { return arr[Math.floor(Math.random() * arr.length)]; }
    function randInt(min, max) { return Math.floor(Math.random() * (max - min + 1)) + min; }

    function generateCombo() {
      const level = tricksData.skill_levels[currentLevel];
      const tricks = getFilteredTricks();
      if (tricks.length < 2) return null;

      const len = randInt(level.combo_length[0], level.combo_length[1]);
      const combo = [];
      const connectors = [];
      const used = new Set();

      for (let i = 0; i < len; i++) {
        let available = tricks.filter(t => !used.has(t.name));
        if (available.length === 0) available = tricks;
        const t = pick(available);
        used.add(t.name);
        combo.push(t);
        if (i < len - 1) connectors.push(pick(tricksData.connectors));
      }

      const totalDiff = combo.reduce((s, t) => s + t.difficulty, 0) +
        connectors.reduce((s, c) => s + c.difficulty_add, 0);

      return { combo, connectors, totalDifficulty: totalDiff };
    }

    function renderDots(diff, max = 8) {
      let html = '';
      for (let i = 1; i <= max; i++) {
        html += `<div class="dot${i <= diff ? ' filled' : ''}"></div>`;
      }
      return html;
    }

    function deriveLevelFromDifficulty(totalDiff, trickCount) {
      // Compute average difficulty per trick
      const avg = trickCount > 0 ? totalDiff / trickCount : 0;
      // Map average difficulty to level using skill_levels max_difficulty thresholds
      if (tricksData && tricksData.skill_levels) {
        const levels = ['beginner', 'intermediate', 'advanced', 'pro'];
        for (let i = 0; i < levels.length; i++) {
          const sl = tricksData.skill_levels[levels[i]];
          if (sl && avg <= sl.max_difficulty) return levels[i];
        }
        return 'pro';
      }
      // Fallback if no tricksData
      if (avg <= 2) return 'beginner';
      if (avg <= 4) return 'intermediate';
      if (avg <= 6) return 'advanced';
      return 'pro';
    }

    function renderCombo(result) {
      const display = document.getElementById('comboDisplay');
      display.classList.remove('empty');

      let html = '<div class="combo-tricks">';
      result.combo.forEach((trick, i) => {
        html += `<div class="trick-card">
          <span class="trick-name">${trick.name}</span>
          <div class="trick-meta">
            <span class="trick-stance">${trick.stance[0]}</span>
            <div class="trick-difficulty">${renderDots(trick.difficulty)}</div>
          </div>
        </div>`;
        if (i < result.combo.length - 1) {
          html += `<div class="connector">‚Üì ${result.connectors[i].name}</div>`;
        }
      });
      html += '</div>';
      html += `<div class="combo-stats">
        <span>Tricks: <strong>${result.combo.length}</strong></span>
        <span>Total Difficulty: <strong>${result.totalDifficulty}</strong></span>
        <span>Level: <strong>${deriveLevelFromDifficulty(result.totalDifficulty, result.combo.length)}</strong></span>
      </div>`;

      display.innerHTML = html;
    }

    function comboToString(result) {
      return result.combo.map(t => t.name).join(' ‚Üí ');
    }

    function addToHistory(result) {
      const str = comboToString(result);
      const derivedLevel = deriveLevelFromDifficulty(result.totalDifficulty, result.combo.length);
      history.unshift({ text: str, result, level: derivedLevel });
      if (history.length > 10) history.pop();
      renderHistory();
    }

    function renderHistory() {
      const section = document.getElementById('historySection');
      const list = document.getElementById('historyList');
      if (history.length === 0) { section.style.display = 'none'; return; }
      section.style.display = 'block';
      list.innerHTML = history.map((h, i) =>
        `<div class="history-item" onclick="replayHistory(${i})">${h.text} <span style="color:var(--text-dim);font-size:0.8rem">(${h.level})</span></div>`
      ).join('');
    }

    window.replayHistory = function(i) {
      renderCombo(history[i].result);
    };

    document.getElementById('levelBtns').addEventListener('click', e => {
      const btn = e.target.closest('[data-level]');
      if (!btn) return;
      document.querySelectorAll('#levelBtns .btn').forEach(b => b.classList.remove('active'));
      btn.classList.add('active');
      currentLevel = btn.dataset.level;
    });

    document.getElementById('stanceBtns').addEventListener('click', e => {
      const btn = e.target.closest('[data-stance]');
      if (!btn) return;
      document.querySelectorAll('#stanceBtns .btn').forEach(b => b.classList.remove('active'));
      btn.classList.add('active');
      currentStance = btn.dataset.stance;
    });

    document.getElementById('categoryBtns').addEventListener('click', e => {
      const btn = e.target.closest('[data-category]');
      if (!btn) return;
      document.querySelectorAll('#categoryBtns .btn').forEach(b => b.classList.remove('active'));
      btn.classList.add('active');
      currentCategory = btn.dataset.category;
    });

    document.getElementById('generateBtn').addEventListener('click', () => {
      if (!tricksData) return;
      const result = generateCombo();
      if (!result) {
        const display = document.getElementById('comboDisplay');
        display.classList.add('empty');
        display.innerHTML = '<span style="color:var(--accent);font-size:1.1rem;padding:1rem;">üç≥ Not enough tricks for this filter combo.<br>Try a different difficulty level or stance!</span>';
        return;
      }
      renderCombo(result);
      addToHistory(result);
    });

    // --- Favorites (localStorage) ---
    let favorites = JSON.parse(localStorage.getItem('comboKitchen_favorites') || '[]');
    let lastGeneratedResult = null;

    function saveFavorites() {
      localStorage.setItem('comboKitchen_favorites', JSON.stringify(favorites));
    }

    function comboKey(result) {
      return result.combo.map(t => t.name).join('|');
    }

    function isFavorited(result) {
      const key = comboKey(result);
      return favorites.some(f => f.key === key);
    }

    function toggleFavorite(result) {
      const key = comboKey(result);
      const idx = favorites.findIndex(f => f.key === key);
      if (idx >= 0) {
        favorites.splice(idx, 1);
      } else {
        favorites.unshift({
          key,
          text: comboToString(result),
          result,
          level: deriveLevelFromDifficulty(result.totalDifficulty, result.combo.length),
          savedAt: new Date().toISOString()
        });
      }
      saveFavorites();
      updateFavButton(result);
      renderFavorites();
    }

    function updateFavButton(result) {
      const btn = document.getElementById('favBtn');
      if (!btn) return;
      const faved = isFavorited(result);
      btn.textContent = faved ? '‚≠ê Saved!' : 'ü§ç Save to Favorites';
      btn.classList.toggle('saved', faved);
    }

    function renderFavorites() {
      const section = document.getElementById('favoritesSection');
      const list = document.getElementById('favoritesList');
      if (favorites.length === 0) { section.style.display = 'none'; return; }
      section.style.display = 'block';
      list.innerHTML = favorites.map((f, i) =>
        `<div class="fav-item">
          <div class="fav-text" onclick="replayFavorite(${i})">
            ${f.text}
            <div class="fav-meta">${f.level} ¬∑ saved ${new Date(f.savedAt).toLocaleDateString()}</div>
          </div>
          <button class="fav-remove" onclick="removeFavorite(${i})" title="Remove">‚úï</button>
        </div>`
      ).join('');
    }

    window.replayFavorite = function(i) {
      lastGeneratedResult = favorites[i].result;
      renderCombo(favorites[i].result);
      updateFavButton(favorites[i].result);
    };

    window.removeFavorite = function(i) {
      favorites.splice(i, 1);
      saveFavorites();
      renderFavorites();
      if (lastGeneratedResult) updateFavButton(lastGeneratedResult);
    };

    // Patch renderCombo to add fav button
    const _origRenderCombo = renderCombo;
    renderCombo = function(result) {
      _origRenderCombo(result);
      lastGeneratedResult = result;
      const display = document.getElementById('comboDisplay');
      const btn = document.createElement('button');
      btn.id = 'favBtn';
      btn.className = 'fav-btn' + (isFavorited(result) ? ' saved' : '');
      btn.textContent = isFavorited(result) ? '‚≠ê Saved!' : 'ü§ç Save to Favorites';
      btn.onclick = () => toggleFavorite(result);
      display.appendChild(btn);
    };

    renderFavorites();

    // --- Timer Mode ---
    let timerEnabled = false;
    let timerInterval = null;
    let timerStart = 0;
    let timerDurationMs = 0;
    let timerStreak = parseInt(localStorage.getItem('comboKitchen_streak') || '0');
    let timerRunning = false;

    const timerToggle = document.getElementById('timerToggle');
    const timerDisplay = document.getElementById('timerDisplay');
    const timerBarContainer = document.getElementById('timerBarContainer');
    const timerBar = document.getElementById('timerBar');
    const timerResult = document.getElementById('timerResult');
    const timerActions = document.getElementById('timerActions');
    const timerSettings = document.getElementById('timerSettings');
    const timerStreakEl = document.getElementById('timerStreak');
    const streakCount = document.getElementById('streakCount');
    const timerDurationSelect = document.getElementById('timerDuration');

    function updateStreakDisplay() {
      streakCount.textContent = timerStreak;
      if (timerEnabled) timerStreakEl.classList.add('active');
      else timerStreakEl.classList.remove('active');
    }

    timerToggle.addEventListener('change', () => {
      timerEnabled = timerToggle.checked;
      timerSettings.classList.toggle('active', timerEnabled);
      updateStreakDisplay();
      if (!timerEnabled) stopTimer();
    });

    function calcAutoTime(result) {
      // ~5s per difficulty point, min 10s, max 120s
      const total = result.totalDifficulty;
      return Math.min(120, Math.max(10, total * 5)) * 1000;
    }

    function startTimer(result) {
      stopTimer();
      const sel = timerDurationSelect.value;
      timerDurationMs = sel === 'auto' ? calcAutoTime(result) : parseInt(sel) * 1000;
      timerStart = Date.now();
      timerRunning = true;

      timerDisplay.classList.add('active');
      timerBarContainer.classList.add('active');
      timerActions.classList.add('active');
      timerResult.innerHTML = '';
      timerResult.className = 'timer-result';
      timerBar.style.width = '100%';
      timerBar.className = 'timer-bar';
      timerDisplay.className = 'timer-display active';

      timerInterval = setInterval(() => {
        const elapsed = Date.now() - timerStart;
        const remaining = Math.max(0, timerDurationMs - elapsed);
        const pct = (remaining / timerDurationMs) * 100;

        // Update display
        const secs = Math.ceil(remaining / 1000);
        const m = Math.floor(secs / 60);
        const s = secs % 60;
        timerDisplay.textContent = `${m}:${s.toString().padStart(2, '0')}`;

        // Update bar
        timerBar.style.width = pct + '%';

        // Color states
        timerBar.className = 'timer-bar' + (pct < 20 ? ' danger' : pct < 40 ? ' warning' : '');
        timerDisplay.className = 'timer-display active' + (pct < 20 ? ' danger' : pct < 40 ? ' warning' : '');

        if (remaining <= 0) {
          endTimer(false);
        }
      }, 50);
    }

    function stopTimer() {
      if (timerInterval) clearInterval(timerInterval);
      timerInterval = null;
      timerRunning = false;
      timerDisplay.classList.remove('active');
      timerBarContainer.classList.remove('active');
      timerActions.classList.remove('active');
    }

    function endTimer(landed) {
      if (timerInterval) clearInterval(timerInterval);
      timerInterval = null;
      timerRunning = false;
      timerActions.classList.remove('active');
      timerBarContainer.classList.remove('active');

      const elapsed = ((Date.now() - timerStart) / 1000).toFixed(1);

      if (landed) {
        timerStreak++;
        timerDisplay.textContent = 'üéâ';
        timerDisplay.className = 'timer-display active';
        timerResult.className = 'timer-result success';
        timerResult.innerHTML = `Landed in ${elapsed}s! Streak: ${timerStreak} üî•`;
      } else {
        timerStreak = 0;
        timerDisplay.textContent = 'üíÄ';
        timerDisplay.className = 'timer-display active';
        timerResult.className = 'timer-result fail';
        timerResult.innerHTML = elapsed >= (timerDurationMs / 1000) ? `‚è∞ Time's up! Streak reset.` : `Bailed! Streak reset.`;
      }

      localStorage.setItem('comboKitchen_streak', timerStreak.toString());
      updateStreakDisplay();

      setTimeout(() => {
        timerDisplay.classList.remove('active');
      }, 2000);
    }

    document.getElementById('landedBtn').addEventListener('click', () => { if (timerRunning) endTimer(true); });
    document.getElementById('bailBtn').addEventListener('click', () => { if (timerRunning) endTimer(false); });

    updateStreakDisplay();

    // Patch generate to start timer
    const origGenClick = document.getElementById('generateBtn').onclick;
    document.getElementById('generateBtn').addEventListener('click', () => {
      if (timerEnabled && lastGeneratedResult) {
        setTimeout(() => startTimer(lastGeneratedResult), 100);
      }
    });

    // --- Share as Image / Link ---
    function showToast(msg) {
      const t = document.getElementById('shareToast');
      t.textContent = msg;
      t.classList.add('show');
      setTimeout(() => t.classList.remove('show'), 2500);
    }

    function comboToShareUrl(result) {
      const tricks = result.combo.map(t => t.name);
      const conns = result.connectors.map(c => c.name);
      const params = new URLSearchParams({
        t: tricks.join('|'),
        c: conns.join('|'),
        l: currentLevel
      });
      return `${location.origin}${location.pathname}?${params}`;
    }

    function generateComboImage(result) {
      return new Promise(resolve => {
        const W = 800, pad = 40;
        const tricks = result.combo;
        const conns = result.connectors;
        const rowH = 54, connH = 30, headerH = 80, footerH = 50;
        const H = headerH + tricks.length * rowH + conns.length * connH + footerH + pad * 2;

        const canvas = document.createElement('canvas');
        canvas.width = W; canvas.height = H;
        const ctx = canvas.getContext('2d');

        // Background
        ctx.fillStyle = '#1a1a2e';
        ctx.fillRect(0, 0, W, H);

        // Header
        ctx.fillStyle = '#eee';
        ctx.font = 'bold 32px system-ui, sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText('üç≥ Combo Kitchen', W / 2, pad + 36);
        ctx.fillStyle = '#999';
        ctx.font = '16px system-ui, sans-serif';
        const imgLevel = deriveLevelFromDifficulty(result.totalDifficulty, tricks.length);
        ctx.fillText(`${imgLevel.charAt(0).toUpperCase() + imgLevel.slice(1)} ¬∑ ${tricks.length} tricks ¬∑ Difficulty ${result.totalDifficulty}`, W / 2, pad + 62);

        let y = pad + headerH;

        tricks.forEach((trick, i) => {
          // Trick card bg
          ctx.fillStyle = '#16213e';
          const cardX = 60, cardW = W - 120, cardH = 44;
          ctx.beginPath();
          ctx.roundRect(cardX, y, cardW, cardH, 10);
          ctx.fill();

          // Trick name
          ctx.fillStyle = '#eee';
          ctx.font = 'bold 20px system-ui, sans-serif';
          ctx.textAlign = 'left';
          ctx.fillText(trick.name, cardX + 16, y + 28);

          // Stance badge
          ctx.fillStyle = '#999';
          ctx.font = '13px system-ui, sans-serif';
          ctx.textAlign = 'right';
          ctx.fillText(trick.stance[0], cardX + cardW - 16, y + 28);

          // Difficulty dots
          const dotR = 4, dotGap = 12, dotsX = cardX + cardW - 100;
          for (let d = 0; d < 8; d++) {
            ctx.beginPath();
            ctx.arc(dotsX + d * dotGap, y + 28, dotR, 0, Math.PI * 2);
            ctx.fillStyle = d < trick.difficulty ? '#e94560' : '#333';
            ctx.fill();
          }

          y += rowH;

          // Connector
          if (i < conns.length) {
            ctx.fillStyle = '#f5c518';
            ctx.font = '14px system-ui, sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText(`‚Üì ${conns[i].name}`, W / 2, y + 18);
            y += connH;
          }
        });

        // Footer
        y += 10;
        ctx.fillStyle = '#666';
        ctx.font = '13px system-ui, sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText('clawdiard.github.io/combo-kitchen', W / 2, y + 20);

        canvas.toBlob(blob => resolve(blob), 'image/png');
      });
    }

    async function shareCombo(result) {
      const shareUrl = comboToShareUrl(result);
      const shareLevel = deriveLevelFromDifficulty(result.totalDifficulty, result.combo.length);
      const text = `üç≥ Combo Kitchen\n${comboToString(result)}\n${shareLevel} ¬∑ Difficulty ${result.totalDifficulty}`;

      // Try native share with image
      if (navigator.canShare) {
        try {
          const blob = await generateComboImage(result);
          const file = new File([blob], 'combo.png', { type: 'image/png' });
          if (navigator.canShare({ files: [file] })) {
            await navigator.share({ text: text + '\n' + shareUrl, files: [file] });
            return;
          }
        } catch (e) { if (e.name === 'AbortError') return; }
      }

      // Try native share without image
      if (navigator.share) {
        try {
          await navigator.share({ title: 'Combo Kitchen', text, url: shareUrl });
          return;
        } catch (e) { if (e.name === 'AbortError') return; }
      }

      // Fallback: copy link
      try {
        await navigator.clipboard.writeText(text + '\n' + shareUrl);
        showToast('üìã Combo copied to clipboard!');
      } catch (e) {
        showToast('Share URL: ' + shareUrl);
      }
    }

    async function downloadComboImage(result) {
      const blob = await generateComboImage(result);
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url; a.download = 'combo-kitchen.png';
      document.body.appendChild(a); a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
      showToast('üì∏ Image downloaded!');
    }

    // Load shared combo from URL params
    function loadSharedCombo() {
      const params = new URLSearchParams(location.search);
      if (!params.has('t')) return;
      const trickNames = params.get('t').split('|');
      const connNames = params.get('c').split('|');
      const level = params.get('l') || 'intermediate';

      // Wait for tricks data
      const check = setInterval(() => {
        if (!tricksData) return;
        clearInterval(check);

        const tricks = trickNames.map(name => {
          const found = tricksData.tricks.find(t => t.name === name);
          return found || { name, difficulty: 0, stance: ['?'], category: 'unknown' };
        });
        const conns = connNames.map(name => {
          const found = tricksData.connectors.find(c => c.name === name);
          return found || { name, difficulty_add: 0 };
        });
        const totalDiff = tricks.reduce((s, t) => s + t.difficulty, 0) + conns.reduce((s, c) => s + c.difficulty_add, 0);

        currentLevel = level;
        document.querySelectorAll('#levelBtns .btn').forEach(b => {
          b.classList.toggle('active', b.dataset.level === level);
        });

        const result = { combo: tricks, connectors: conns, totalDifficulty: totalDiff };
        renderCombo(result);
        addToHistory(result);
      }, 100);
    }

    // Patch renderCombo to add share buttons
    const _shareRenderCombo = renderCombo;
    renderCombo = function(result) {
      _shareRenderCombo(result);
      lastGeneratedResult = result;
      const display = document.getElementById('comboDisplay');
      // Wrap fav + share buttons in actions row
      const favBtn = display.querySelector('.fav-btn');
      const actionsDiv = document.createElement('div');
      actionsDiv.className = 'combo-actions';
      if (favBtn) actionsDiv.appendChild(favBtn);

      const shareBtn = document.createElement('button');
      shareBtn.className = 'share-btn';
      shareBtn.innerHTML = 'üì§ Share';
      shareBtn.onclick = () => shareCombo(result);
      actionsDiv.appendChild(shareBtn);

      const imgBtn = document.createElement('button');
      imgBtn.className = 'share-btn';
      imgBtn.innerHTML = 'üì∏ Save Image';
      imgBtn.onclick = () => downloadComboImage(result);
      actionsDiv.appendChild(imgBtn);

      display.appendChild(actionsDiv);
    };

    // --- Mode Tabs (Random vs Builder) ---
    let currentMode = 'random';
    const builderPanel = document.getElementById('builderPanel');
    const builderTrickList = document.getElementById('builderTrickList');
    const builderCombo = document.getElementById('builderCombo');
    const builderActions = document.getElementById('builderActions');
    const trickSearchInput = document.getElementById('trickSearch');
    let builderTricks = []; // [{trick, connector}]

    document.querySelector('.mode-tabs').addEventListener('click', e => {
      const tab = e.target.closest('.mode-tab');
      if (!tab) return;
      document.querySelectorAll('.mode-tab').forEach(t => t.classList.remove('active'));
      tab.classList.add('active');
      currentMode = tab.dataset.mode;
      document.getElementById('generateBtn').style.display = currentMode === 'random' ? '' : 'none';
      builderPanel.classList.toggle('active', currentMode === 'builder');
      // Clear error/empty state from comboDisplay on mode switch
      const display = document.getElementById('comboDisplay');
      if (display.classList.contains('empty')) {
        display.classList.add('empty');
        display.innerHTML = '<span style="opacity:.5">üç≥ Your combo will appear here‚Ä¶</span>';
      }
      if (currentMode === 'builder') refreshBuilderTricks();
    });

    function refreshBuilderTricks(filter = '') {
      if (!tricksData) return;
      const tricks = getFilteredTricks();
      const lower = filter.toLowerCase();
      const filtered = lower ? tricks.filter(t => t.name.toLowerCase().includes(lower)) : tricks;
      builderTrickList.innerHTML = filtered.map(t =>
        `<div class="builder-trick-chip" data-trick="${t.name}">${t.name}<span class="chip-diff">‚òÖ${t.difficulty}</span></div>`
      ).join('');
    }

    trickSearchInput.addEventListener('input', () => refreshBuilderTricks(trickSearchInput.value));

    // Also refresh when filters change
    ['levelBtns', 'stanceBtns', 'categoryBtns'].forEach(id => {
      document.getElementById(id).addEventListener('click', () => {
        setTimeout(() => { if (currentMode === 'builder') refreshBuilderTricks(trickSearchInput.value); }, 10);
      });
    });

    builderTrickList.addEventListener('click', e => {
      const chip = e.target.closest('.builder-trick-chip');
      if (!chip || !tricksData) return;
      const trick = tricksData.tricks.find(t => t.name === chip.dataset.trick);
      if (!trick) return;
      builderTricks.push({ trick, connector: 'into' });
      renderBuilderCombo();
    });

    function renderBuilderCombo() {
      if (builderTricks.length === 0) {
        builderCombo.innerHTML = '<div class="builder-empty">Pick tricks from above to build your combo</div>';
        builderActions.style.display = 'none';
        return;
      }
      builderActions.style.display = 'flex';
      const connectors = tricksData ? tricksData.connectors : [{name:'into'},{name:'to'},{name:'late'},{name:'to fakie'}];
      let html = '';
      builderTricks.forEach((item, i) => {
        html += `<div class="builder-combo-item">
          <span class="trick-label">${item.trick.name}</span>
          <button class="remove-trick" data-idx="${i}">‚úï</button>
        </div>`;
        if (i < builderTricks.length - 1) {
          html += `<div class="builder-connector-select">
            <select data-conn-idx="${i}">
              ${connectors.map(c => `<option value="${c.name}"${c.name === item.connector ? ' selected' : ''}>${c.name}</option>`).join('')}
            </select>
          </div>`;
        }
      });
      builderCombo.innerHTML = html;
    }

    builderCombo.addEventListener('click', e => {
      const btn = e.target.closest('.remove-trick');
      if (!btn) return;
      builderTricks.splice(parseInt(btn.dataset.idx), 1);
      renderBuilderCombo();
    });

    builderCombo.addEventListener('change', e => {
      if (e.target.dataset.connIdx !== undefined) {
        builderTricks[parseInt(e.target.dataset.connIdx)].connector = e.target.value;
      }
    });

    document.getElementById('builderClear').addEventListener('click', () => {
      builderTricks = [];
      renderBuilderCombo();
    });

    document.getElementById('builderCook').addEventListener('click', () => {
      if (builderTricks.length < 2 || !tricksData) return;
      const combo = builderTricks.map(b => b.trick);
      const conns = builderTricks.slice(0, -1).map(b => {
        const found = tricksData.connectors.find(c => c.name === b.connector);
        return found || { name: b.connector, difficulty_add: 0 };
      });
      const totalDiff = combo.reduce((s, t) => s + t.difficulty, 0) + conns.reduce((s, c) => s + c.difficulty_add, 0);
      const result = { combo, connectors: conns, totalDifficulty: totalDiff };
      renderCombo(result);
      addToHistory(result);
      if (timerEnabled) setTimeout(() => startTimer(result), 100);
    });

    loadSharedCombo();

    loadTricks();
  </script>
</body>
</html>
